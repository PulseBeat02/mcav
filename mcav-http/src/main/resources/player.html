<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audio Stream Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --primary-color: #1db954;
            --secondary-color: #191414;
            --text-color: #f5f5f5;
            --text-secondary: #b3b3b3;
            --background-color: #121212;
            --panel-bg: rgba(40, 40, 40, 0.8);
            --hover-bg: rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--secondary-color), #333);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .player-container {
            background: var(--panel-bg);
            width: 100%;
            max-width: 800px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .player-header {
            background: var(--secondary-color);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .player-header h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }

        .media-info {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            align-items: flex-start;
            min-height: 120px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.5s ease;
        }

        .media-info.loaded {
            opacity: 1;
            transform: translateY(0);
        }

        .media-thumbnail {
            width: 120px;
            height: 120px;
            min-width: 120px;
            border-radius: 8px;
            background: linear-gradient(135deg, #333, #555);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .media-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .media-thumbnail .placeholder-icon {
            font-size: 48px;
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .media-details {
            flex: 1;
            min-width: 0;
        }

        .media-title {
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 8px 0;
            color: var(--text-color);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .media-uploader {
            font-size: 14px;
            color: var(--text-secondary);
            margin: 0 0 12px 0;
        }

        .media-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .visualizer {
            background: rgba(0, 0, 0, 0.3);
            height: 150px;
            margin: 20px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .visualizer-canvas {
            width: 100%;
            height: 100%;
            display: none;
        }

        .visualizer-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }

        .controls {
            display: flex;
            justify-content: center;
            padding: 20px;
            gap: 15px;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 100px;
            outline: none;
        }

        .btn:hover {
            background: #1ed760;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .volume-control {
            display: flex;
            align-items: center;
            padding: 0 20px 20px;
            gap: 10px;
        }

        .volume-icon {
            font-size: 20px;
            min-width: 24px;
        }

        .volume-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .status-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px 20px;
            font-size: 14px;
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        #status {
            color: rgba(255, 255, 255, 0.7);
        }

        .status-connected {
            color: var(--primary-color) !important;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 600px) {
            .player-container {
                width: 95%;
            }

            .visualizer {
                height: 100px;
            }

            .media-info {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }

            .media-thumbnail {
                width: 100px;
                height: 100px;
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
<div class="player-container">
    <div class="player-header">
        <h1>Audio Stream Player</h1>
    </div>

    <div class="media-info" id="media-info">
        <div class="media-thumbnail" id="media-thumbnail">
            <span class="placeholder-icon">&#9834;</span>
        </div>
        <div class="media-details">
            <h2 class="media-title" id="media-title">Waiting for stream...</h2>
            <p class="media-uploader" id="media-uploader">Unknown Artist</p>
            <p class="media-description" id="media-description">Connect to start streaming</p>
        </div>
    </div>

    <div class="visualizer">
        <div class="visualizer-placeholder">Connect to start visualization</div>
        <canvas class="visualizer-canvas" id="visualizer-canvas"></canvas>
    </div>

    <div class="volume-control">
        <div class="volume-icon">&#128266;</div>
        <input type="range" min="0" max="100" value="100" class="volume-slider" id="volume">
    </div>

    <div class="controls">
        <button id="start" class="btn">Start</button>
        <button id="stop" class="btn" disabled>Stop</button>
    </div>

    <div class="status-panel">
        <div id="status">Disconnected</div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"
        integrity="sha512-xi/RZRIF/S0hJ+yJJYuZ5yk6/8pCiRlEXZzoguSMl+vk2i3m6UjUO/WcZ11blRL/O+rnj94JRGwt/CHbc9+6EA=="
        crossorigin="anonymous"></script>
<script>
    let audioContext;
    let ws;
    let pcmProcessor;
    let animationId;
    let metadataInterval;
    let heartbeatInterval;
    let reconnectTimeout;
    let shouldReconnect = false;
    const statusEl = document.getElementById('status');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const volumeSlider = document.getElementById('volume');
    const visualizerCanvas = document.getElementById('visualizer-canvas');
    const visualizerCtx = visualizerCanvas.getContext('2d');
    const visualizerPlaceholder = document.querySelector('.visualizer-placeholder');
    const mediaInfo = document.getElementById('media-info');
    const mediaThumbnail = document.getElementById('media-thumbnail');
    const mediaTitle = document.getElementById('media-title');
    const mediaUploader = document.getElementById('media-uploader');
    const mediaDescription = document.getElementById('media-description');

    function resizeCanvas() {
        const rect = visualizerCanvas.parentElement.getBoundingClientRect();
        visualizerCanvas.width = rect.width;
        visualizerCanvas.height = rect.height;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    class PCMProcessor {
        constructor(options) {
            this.options = {
                encoding: options.encoding || '16bitInt',
                channels: options.channels || 2,
                sampleRate: options.sampleRate || 48000,
                flushingTime: options.flushingTime || 2000
            };
            this.samples = new Float32Array();
            this.audioCtx = options.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            this.setupHowler();
            this.waveformData = new Float32Array(256);
            this.smoothedData = new Float32Array(256);
            this.isDestroyed = false;
            this.activeSources = new Set();
            this.hue = 0;

            this.gainNode = this.audioCtx.createGain();
            this.gainNode.connect(this.audioCtx.destination);
            this.startTime = this.audioCtx.currentTime;
        }

        setupHowler() {
            Howler.ctx = this.audioCtx;
        }

        feed(data) {
            if (this.isDestroyed) return;

            const view = new DataView(data);
            const float32Array = new Float32Array(data.byteLength / 2);
            for (let i = 0; i < float32Array.length; i++) {
                const int16 = view.getInt16(i * 2, true);
                float32Array[i] = int16 / 32768.0;
            }

            this.updateVisualizer(float32Array);

            const newSamples = new Float32Array(this.samples.length + float32Array.length);
            newSamples.set(this.samples);
            newSamples.set(float32Array, this.samples.length);
            this.samples = newSamples;
            if (this.samples.length / this.options.channels > this.options.sampleRate / 2) {
                this.play();
            }
        }

        updateVisualizer(data) {
            if (this.isDestroyed) return;

            if (!animationId) {
                this.animateVisualizer();
            }

            const samplesPerPoint = Math.floor(data.length / this.waveformData.length);
            for (let i = 0; i < this.waveformData.length; i++) {
                let sum = 0;
                let max = 0;
                for (let j = 0; j < samplesPerPoint; j++) {
                    const idx = i * samplesPerPoint + j;
                    if (idx < data.length) {
                        sum += Math.abs(data[idx]);
                        max = Math.max(max, Math.abs(data[idx]));
                    }
                }
                const avg = sum / samplesPerPoint;
                this.waveformData[i] = max * 2;
                this.smoothedData[i] = this.smoothedData[i] * 0.85 + this.waveformData[i] * 0.15;
            }
        }

        animateVisualizer() {
            visualizerPlaceholder.style.display = 'none';
            visualizerCanvas.style.display = 'block';

            const draw = () => {
                if (this.isDestroyed) return;

                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const centerY = height / 2;

                visualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                visualizerCtx.fillRect(0, 0, width, height);

                const gradient = visualizerCtx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, `hsl(${this.hue}, 100%, 50%)`);
                gradient.addColorStop(0.5, `hsl(${this.hue + 60}, 100%, 50%)`);
                gradient.addColorStop(1, `hsl(${this.hue + 120}, 100%, 50%)`);

                visualizerCtx.strokeStyle = gradient;
                visualizerCtx.lineWidth = 3;
                visualizerCtx.shadowBlur = 20;
                visualizerCtx.shadowColor = `hsl(${this.hue + 60}, 100%, 50%)`;

                visualizerCtx.beginPath();
                for (let i = 0; i < this.smoothedData.length; i++) {
                    const x = (i / this.smoothedData.length) * width;
                    const amplitude = this.smoothedData[i] * height * 0.4;
                    const y1 = centerY - amplitude;
                    const y2 = centerY + amplitude;

                    if (i === 0) {
                        visualizerCtx.moveTo(x, centerY);
                    }
                    visualizerCtx.lineTo(x, y1);
                }

                for (let i = this.smoothedData.length - 1; i >= 0; i--) {
                    const x = (i / this.smoothedData.length) * width;
                    const amplitude = this.smoothedData[i] * height * 0.4;
                    const y2 = centerY + amplitude;
                    visualizerCtx.lineTo(x, y2);
                }

                visualizerCtx.closePath();
                visualizerCtx.stroke();

                const fillGradient = visualizerCtx.createLinearGradient(0, 0, 0, height);
                fillGradient.addColorStop(0, `hsla(${this.hue}, 100%, 50%, 0.3)`);
                fillGradient.addColorStop(0.5, `hsla(${this.hue + 60}, 100%, 50%, 0.1)`);
                fillGradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0.3)`);
                visualizerCtx.fillStyle = fillGradient;
                visualizerCtx.fill();

                this.hue = (this.hue + 0.5) % 360;

                animationId = requestAnimationFrame(draw);
            };

            animationId = requestAnimationFrame(draw);
        }

        play() {
            if (this.samples.length === 0 || this.isDestroyed) return;

            const bufferSource = this.audioCtx.createBufferSource();
            const length = this.samples.length / this.options.channels;
            const audioBuffer = this.audioCtx.createBuffer(
                this.options.channels,
                length,
                this.options.sampleRate
            );

            for (let channel = 0; channel < this.options.channels; channel++) {
                const audioData = audioBuffer.getChannelData(channel);
                let offset = channel;
                let decrement = 50;
                for (let i = 0; i < length; i++) {
                    audioData[i] = this.samples[offset];
                    if (i < 50) {
                        audioData[i] = (audioData[i] * i) / 50;
                    }
                    if (i >= (length - 51)) {
                        audioData[i] = (audioData[i] * decrement--) / 50;
                    }
                    offset += this.options.channels;
                }
            }

            if (this.startTime < this.audioCtx.currentTime) {
                this.startTime = this.audioCtx.currentTime;
            }

            bufferSource.buffer = audioBuffer;
            bufferSource.connect(this.gainNode);

            this.activeSources.add(bufferSource);

            bufferSource.onended = () => {
                this.activeSources.delete(bufferSource);
            };

            bufferSource.start(this.startTime);
            this.startTime += audioBuffer.duration;
            this.samples = new Float32Array();
        }

        destroy() {
            this.isDestroyed = true;

            this.activeSources.forEach(source => {
                try {
                    source.stop(this.audioCtx.currentTime);
                    source.disconnect();
                } catch (e) {
                }
            });
            this.activeSources.clear();

            if (this.gainNode) {
                try {
                    this.gainNode.disconnect();
                } catch (e) {
                }
                this.gainNode = null;
            }

            this.samples = new Float32Array();
            this.startTime = 0;

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            visualizerPlaceholder.style.display = 'block';
            visualizerCanvas.style.display = 'none';
            visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            this.waveformData = new Float32Array(256);
            this.smoothedData = new Float32Array(256);
        }

        flush() {
            this.activeSources.forEach(source => {
                try {
                    source.stop(this.audioCtx.currentTime);
                } catch (e) {
                }
            });
            this.activeSources.clear();

            this.samples = new Float32Array();
            this.startTime = this.audioCtx.currentTime;
        }
    }

    async function fetchMediaInfo() {
        try {
            const response = await fetch('/media');
            if (!response.ok) {
                throw new Error('Failed to fetch media info');
            }

            const data = await response.json();
            updateMediaInfo(data);
        } catch (error) {
            console.error('Error fetching media info:', error);
            updateMediaInfo(null);
        }
    }

    function updateMediaInfo(data) {
        const title = data?.title || 'Unknown Title';
        const uploader = data?.uploader || 'Unknown Artist';
        const description = data?.description || 'No description available';
        const thumbnail = data?.thumbnail;

        mediaTitle.textContent = title;
        mediaUploader.textContent = uploader;
        mediaDescription.textContent = description;

        if (thumbnail) {
            const img = document.createElement('img');
            img.src = thumbnail;
            img.alt = title;
            img.onload = () => {
                mediaThumbnail.innerHTML = '';
                mediaThumbnail.appendChild(img);
            };
            img.onerror = () => {
                mediaThumbnail.innerHTML = '<span class="placeholder-icon">&#9834;</span>';
            };
        } else {
            mediaThumbnail.innerHTML = '<span class="placeholder-icon">&#9834;</span>';
        }

        mediaInfo.classList.add('loaded');
    }

    function startMetadataRefresh() {
        if (metadataInterval) {
            clearInterval(metadataInterval);
        }
        fetchMediaInfo();
        metadataInterval = setInterval(fetchMediaInfo, 5000);
    }

    function stopMetadataRefresh() {
        if (metadataInterval) {
            clearInterval(metadataInterval);
            metadataInterval = null;
        }
    }

    startBtn.onclick = function () {
        shouldReconnect = true;

        if (pcmProcessor) {
            pcmProcessor.destroy();
            pcmProcessor = null;
        }

        if (audioContext) {
            try {
                audioContext.close();
            } catch (e) {
            }
            audioContext = null;
        }

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        statusEl.textContent = 'Audio permission: ' + audioContext.state;

        if (audioContext.state === 'running') {
            connectWebSocket();
        } else {
            audioContext.resume().then(() => {
                statusEl.textContent = 'Audio permission granted!';
                if (audioContext.state === 'running') {
                    connectWebSocket();
                }
            }).catch(err => {
                statusEl.textContent = 'Failed to get audio permission: ' + err;
            });
        }
    };

    function connectWebSocket() {
        if (pcmProcessor) {
            pcmProcessor.destroy();
            pcmProcessor = null;
        }

        startMetadataRefresh();

        setTimeout(() => {
            try {
                statusEl.innerHTML = '<span class="loading-spinner"></span> Connecting...';

                pcmProcessor = new PCMProcessor({
                    encoding: '16bitInt',
                    channels: 2,
                    sampleRate: 48000,
                    flushingTime: 2000,
                    audioCtx: audioContext
                });

                pcmProcessor.gainNode.gain.value = volumeSlider.value / 100;

                ws = new WebSocket('ws://' + location.hostname + ':%%PORT%%');
                ws.binaryType = 'arraybuffer';

                ws.onopen = function () {
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'status-connected';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    shouldReconnect = true;

                    startHeartbeat();

                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                };

                ws.onmessage = function (e) {
                    if (e.data.byteLength > 0 && pcmProcessor && !pcmProcessor.isDestroyed) {
                        statusEl.textContent = 'Streaming audio';
                        pcmProcessor.feed(e.data);
                    }
                };

                ws.onerror = function (e) {
                    console.error('WebSocket error:', e);
                    if (shouldReconnect) {
                        statusEl.textContent = 'Connection error - reconnecting...';
                        statusEl.className = '';
                        attemptReconnect();
                    } else {
                        statusEl.textContent = 'Connection error';
                        statusEl.className = '';
                        stopStream();
                    }
                };

                ws.onclose = function () {
                    stopHeartbeat();
                    if (shouldReconnect) {
                        statusEl.textContent = 'Disconnected - reconnecting...';
                        statusEl.className = '';
                        attemptReconnect();
                    } else {
                        statusEl.textContent = 'Disconnected';
                        statusEl.className = '';
                        stopStream();
                    }
                };
            } catch (error) {
                console.error('Error starting stream:', error);
                statusEl.textContent = 'Error: ' + error.message;
                statusEl.className = '';
                if (shouldReconnect) {
                    attemptReconnect();
                }
            }
        }, 100);
    }

    function startHeartbeat() {
        stopHeartbeat();
        heartbeatInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(new ArrayBuffer(0));
                } catch (e) {
                    console.error('Heartbeat failed:', e);
                }
            }
        }, 30000);
    }

    function stopHeartbeat() {
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }
    }

    function attemptReconnect() {
        if (reconnectTimeout) return;

        reconnectTimeout = setTimeout(() => {
            reconnectTimeout = null;
            if (shouldReconnect && audioContext && audioContext.state === 'running') {
                connectWebSocket();
            }
        }, 3000);
    }

    stopBtn.onclick = function() {
        shouldReconnect = false;
        stopStream();
    };

    function stopStream() {
        shouldReconnect = false;

        if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
        }

        if (ws) {
            ws.close();
            ws = null;
        }

        if (pcmProcessor) {
            pcmProcessor.destroy();
            pcmProcessor = null;
        }

        stopMetadataRefresh();
        stopHeartbeat();

        startBtn.disabled = false;
        stopBtn.disabled = true;
        statusEl.textContent = 'Disconnected';
        statusEl.className = '';
    }

    volumeSlider.addEventListener('input', function () {
        if (pcmProcessor && pcmProcessor.gainNode) {
            pcmProcessor.gainNode.gain.value = this.value / 100;
        }
        Howler.volume(this.value / 100);
    });

    window.addEventListener('beforeunload', function() {
        shouldReconnect = false;
        stopStream();
        if (audioContext) {
            try {
                audioContext.close();
            } catch (e) {
            }
        }
    });

    fetchMediaInfo();
</script>
</body>
</html>